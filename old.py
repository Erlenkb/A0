from scipy.io import wavfile
import matplotlib.pyplot as plt
import numpy as np
import scipy.signal as signal
import acoustics as ac
from acoustics.bands import third

"""
Uses scipy, matplotlib and numpy. It will use FFT, A-weighting and third octave filters to create a power spectrum of the 
1min file as well as plot the calibration signal and the 1min signal itself
"""

###### Define global variables used
THIRD_OCTAVE_A_WEIGHTING = np.array([
    -63.4, -56.7, -50.5, -44.7, -39.4, -34.6, -30.2, -26.2, -22.5, -19.1, -16.1, -13.4, -10.9, -8.6, -6.6, -4.8, -3.2,
    -1.9, -0.8, +0.0, +0.6, +1.0, +1.2, +1.3, +1.2, +1.0, +0.5, -0.1, -1.1, -2.5, -4.3, -6.6, -9.3
])

third_octave_center_frequencies = [12.5, 16, 20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250,
            315, 400, 500, 630, 800, 1000, 1250, 1600, 2000, 2500, 3150, 4000,
            5000, 6300, 8000, 10000, 12500, 16000, 20000]
p_ref = 2*10**(-5)

def runningMeanFast(x, N):
    """
    :param x: Signal array
    :param N: Window_length
    :return: array with running mean values
    """
    return np.convolve(x, np.ones((N,))/N)[(N-1):]

def third_octave_filter(x_signal, fs, fraction=3, order=6, N= 44100):
    """

    :param x_signal: Signal array
    :param fs: Samplingrate
    :param fraction: ###### CHANGELOG #########: Removed fraction function to make octave filter of fraction=fraction
    :param order: Order of butterworth filter. Default=6
    :param N: N value for FFT. Default = samplingrate
    :return: Return third signal filtered with third octave
    """
    filtered_signal_all = np.zeros(N)
    p_ref = 5*10**(-5)
    limits = third_octave_center_frequencies
    for x in limits:
        f_lower = x*10**((-1)/20)
        f_upper = x*10**(1/20)
        wn = [f_lower,f_upper]
        sos = signal.butter(N=order, Wn=wn, btype="bandpass", fs=fs, output="sos")
        filtered_signal = signal.sosfilt(sos,x_signal)

        fft_spectrum = np.fft.fft(filtered_signal, N)
        fft_spectrum = np.trim_zeros(fft_spectrum, trim="fb")
        filtered_signal_all = filtered_signal_all + fft_spectrum


    fft_spectrum_log = np.fft.fftshift(filtered_signal_all)
    data_log = 10 * np.log10(np.abs(fft_spectrum_log)**2 / p_ref**2)
    freq = np.fft.fftfreq(n=len(data_log), d=(1 / fs))
    freq_log = np.fft.fftshift(freq)
    spectrum_fft = np.abs(filtered_signal_all)
    freq = np.fft.fftfreq(len(spectrum_fft),d=(1/fs))
    spectrum_fft = spectrum_fft[:len(spectrum_fft) // 2]
    freq = freq[:len(freq) // 2]

    return freq, spectrum_fft, freq_log ,data_log

def generate_title(meas_title,rms_value):
    """
    Function to implement title to calibration signal containing dB and Pa values
    :param meas_title: Name of calibration signal
    :param rms_value: signal p_rms value
    :return: title for calibration signal
    """
    Lp = 20*np.log10(rms_value / (20*10**(-6)))
    return str(meas_title +" \n 94dB @ 1KHz -- RMS: " + str(round(rms_value, 5)) + "Pa") + str("\nSound level Lp: " + str(round(Lp,1)) + "dB")

def A_weight(samplingrate):
    """

    :param samplingrate: Samplingrate for the signal to be weighted
    :return: return a and b values to be used to as filter values when signal gets weighted with A-curve
    """
    f1 = 20.598997
    f2 = 107.65265
    f3 = 737.86223
    f4 = 12194.217
    A1000 = -2

    NUMs = [(2 * np.pi * f4) ** 2 * (10 ** (A1000 / 20)), 0, 0, 0, 0]
    DENs = np.polymul([1, 4 * np.pi * f4, (2 * np.pi * f4) ** 2],
                   [1, 4 * np.pi * f1, (2 * np.pi * f1) ** 2])
    DENs = np.polymul(np.polymul(DENs, [1, 2 * np.pi * f3]),
                   [1, 2 * np.pi * f2])

    return signal.bilinear(NUMs, DENs, samplingrate)

def soundPressureLevel(array,window_size):
    """
    Returns the sound pressure level generated by running a window of size "window_size" through the entire signal to find an
    average rms value for each window. Uses the average rms value to find the sound pressure level Lp
    :param array: Signal array
    :param window_size: Size of window
    :return: Sound pressure level Lp, dtype=float64
    """
    p_rms = 0
    n = 0
    state = 1
    while(state==1):
        start = 0+window_size*n
        stop = (window_size-1)+(n*window_size)
        if(stop > len(array)):
            state = 0
        array_window = array[start:stop+1]
        length = len(array_window)
        for i in array_window:
            p_rms = p_rms + ((np.abs(i)**2) / len(array_window))
        n = n+1
    p_rms = p_rms / n
    return 10 * np.log10(p_rms / p_ref**2)

def plotCalibrationBefore(calibration_before,calibration_after):
    """
    Analyze and plot the calibration signals
    :param calibration_before: Name of the calibration siganl file "before" measurements
    :param calibration_after: Name of the calibration siganl file "after" measurements
    :return: A-value to be used to scale discrete .wav values to discrete values representing pressure
    """

    air_peak = 1.41757
    samrate, array = wavfile.read(calibration_before)
    samrate1, array1 = wavfile.read(calibration_after)

    array = array[len(array) // 4 : len(array) - len(array)//4]
    array1 = array1[len(array1) // 4 : len(array1) - len(array1)//4]

    time_Value = len(array) / samrate
    time_Value1 = len(array1) / samrate
    xvalues = np.linspace(0,time_Value,len(array))
    xvalues1 = np.linspace(0, time_Value1,len(array1))

    sorted_array = np.sort(array)
    sorted_array1 = np.sort(array1)
    peak_avg_array = np.mean(sorted_array[-10:])
    peak_avg_array1 = np.mean(sorted_array1[-10:])

    array_avg = np.float64(0)
    array_avg1 = np.float64(0)


    A = peak_avg_array / (air_peak)
    A1 = peak_avg_array1 / (air_peak)
    array = array / A
    array1 = array1 / A1
    print("A-value: {:.1f}".format(A))
    for i in range(len(array)):
        array_avg = array_avg + abs(array[i]**2)
    for i in range(len(array1)):
        array_avg1 = array_avg1 + abs(array1[i]**2)
    array_rms = np.sqrt(array_avg / len(array))
    array1_rms = np.sqrt(array_avg1 / len(array1))


    ##### TESTING DIFFERENT window values and func
    print("Calibration before measurement -- quick func: {:+.1f} dB".format(20 * np.log10(rms_flat(array / (5*10**(-5))))))
    print("Calibration before measurement -- soundpressureLevel func: {:+.1f} dB".format(soundPressureLevel(array,10)))
    print("Calibration before measurement -- soundPressureLevel func N=len(array): {:+.1f} dB".format(soundPressureLevel(array, len(array))))
    print("Calibration before measurement -- soundPressureLevel func N=5512: {:+.1f} dB".format(soundPressureLevel(array, 5512)))
    print("Calibration before measurement -- soundPressureLevel func N=44100: {:+.1f} dB".format(soundPressureLevel(array,44100)))
    print("Calibration before measurement -- soundPressureLevel func N=soundpressureLevel: {:+.1f} dB".format(soundPressureLevel(array,100)))
    print("Calibration after measurement -- quick func:   {:+.1f} dB".format(20 * np.log10(rms_flat(array1 / (5 * 10 ** (-5))))))
    ############################################


    plt.subplot(2,1,1)
    plt.plot(xvalues,array,label="Calibration signal",color="forestgreen")
    plt.xlabel("Time [s]")
    plt.ylabel("Magnitude [Pa]")
    plt.title(generate_title("Calibration before measurements",array_rms))
    plt.legend(loc="upper right")
    plt.grid()

    plt.subplot(2,1,2)
    plt.plot(xvalues1,array1,label="Calibration signal", color="olive")
    plt.xlabel("Time [s]")
    plt.ylabel("Magnitude [Pa]")
    plt.title(generate_title("Calibration after meausurements",array1_rms))
    plt.grid()

    plt.tight_layout()
    plt.legend(loc="upper right")
    plt.show()

    return A

def rms_flat(a):  # from matplotlib.mlab
    """
    Return the root mean square of all the elements of *a*, flattened out.
    """
    return np.sqrt(np.mean(np.absolute(a)**2))

def plotSeperate(array, samplingRate,plot=False, N = 44100 * 6):
    bit_length = (len(array) / samplingRate) / 60

    p_ref = 2*10**(-5)
    xvalues = np.linspace(0,bit_length,len(array))

    b, a = A_weight(samplingRate)
    y = signal.lfilter(b, a, array)

    if(plot):
        plt.plot(xvalues, array, color="dimgray",label="Non-weighted pressure signal")
        plt.plot(xvalues, y, color="forestgreen",label="A-weighted Pressure signal")


        plt.xlabel("Time [min]")
        plt.ylabel("Magnitude [Pa]")
        plt.title(str("Sound recording 30min \nSound pressure level Lp: " + str(round(soundPressureLevel(array, 10),1)) + " dB\nSound pressure level Lp_A: ") + str(round(soundPressureLevel(y,10),1)) +" dB")
        plt.grid()
        plt.legend(loc="upper right")
        plt.tight_layout()
        plt.show()

    y = y * signal.hamming(len(y))
    array = array * signal.hamming(len(array))
    fft_spectrum_y = np.fft.fft(y,N)
    fft_spectrum_y = np.trim_zeros(fft_spectrum_y,trim="fb")
    fft_spectrum_y_shift = np.fft.fftshift(fft_spectrum_y)
    data_log_y = 10 * np.log10(np.abs((fft_spectrum_y_shift) ** 2) / p_ref ** 2)
    freq_y = np.fft.fftfreq(n=len(data_log_y), d=(1 / samplingRate))
    data_log_y = runningMeanFast(data_log_y,5)

    fft_spectrum = np.fft.fft(array,N)
    fft_spectrum = np.trim_zeros(fft_spectrum,trim="fb")
    fft_spectrum_shift = np.fft.fftshift(fft_spectrum)
    data_log = 10 * np.log10(np.abs(fft_spectrum_shift)**2 / (p_ref**2))
    data_log = runningMeanFast(data_log, 5)



    freq_third, spectrum_fft_third, freq_log_third ,data_log_third = third_octave_filter(array, samplingRate, order=50, N=N)
    freq_third_y, spectrum_fft_third_y, freq_log_third_y, data_log_third_y = third_octave_filter(y, samplingRate,order=50, N=N)


    freq = np.fft.fftfreq(n=len(data_log),d=(1/samplingRate))


    freq_shifted = np.fft.fftshift(freq)
    freq_y_shifted = np.fft.fftshift(freq_y)


    indx=0
    third_octave_lower_frequencies = []
    third_octave_upper_frequencies = []
    spl_values = np.zeros(len(freq))
    spl_values_A = np.zeros(len(freq))
    for x in third_octave_center_frequencies:
        third_octave_lower_frequencies.append(x * 10 ** ((-1) / 20))
        third_octave_upper_frequencies.append(x * 10 **(1 / 20))
    temp = []
    temp_A = []
    index = []
    third_octave_lower_frequencies.append(22280)
    for x in range(len(freq_shifted)):
        if(indx < len(third_octave_center_frequencies)):
            if(freq_shifted[x] < third_octave_lower_frequencies[indx+1] and freq_shifted[x] > third_octave_lower_frequencies[indx]):
                temp.append(data_log_third[x])
                temp_A.append(data_log_third_y[x])
                index.append(x)
                if(freq_shifted[x+1] >= third_octave_lower_frequencies[indx+1]):
                    indx = indx + 1
                    Lp = np.mean(temp)
                    LpA = np.mean(temp_A)
                    for i in index:
                        spl_values[i] = Lp
                        spl_values_A[i] = LpA
                    temp = []
                    temp_A = []
                    index = []



    plt.plot(freq,np.abs(fft_spectrum))
    plt.ylabel("Magnitude")
    plt.xlabel("Frequency [Hz]")
    plt.title("FFT-spectrum of 30min recording\n")
    plt.grid()
    plt.xscale("log")
    plt.show()


    fig, ax = plt.subplots()

    fft_spectrum_shift = 20*np.log10(fft_spectrum_shift / p_ref)
    fft_spectrum_y_shift = 20*np.log10(fft_spectrum_y_shift / p_ref)
    s = 0 #len(freq_third)//2
    data_log_lp = ('Non weighted:   {:+.1f} dB'.format((rms_flat(data_log[s:]))))
    data_log_y_lp = ('A weighted:   {:+.1f} dB'.format((rms_flat(data_log_y[s:]))))
    data_log_third_lp = ('Non weighted:   {:+.1f} dB'.format((rms_flat(data_log_third[s:]))))
    data_log_third_y_lp = ('A weighted:   {:+.1f} dB'.format((rms_flat(data_log_third_y[s:]))))

    ax.semilogx(freq_shifted, data_log , color="darkorange",label=str("Power spectrum non-weighted: " + str(data_log_lp) +"dB"))
    ax.semilogx(freq_y_shifted, data_log_y, color="olive",
                label=str("Power spectrum A-weighted: " + str(data_log_y_lp) + "dB"))
    ax.semilogx(freq_shifted, spl_values, color="dimgray",
             label=str("Power spectrum 1/3-octave non-weighted: " + str(data_log_third_lp) + "dB"))
    ax.semilogx(freq_y_shifted, spl_values_A, color="forestgreen",
             label=str("Power spectrum 1/3-octave & A-weighted: " + str(data_log_third_y_lp) + "dB"))

    ax.set_xlabel("Frequency [Hz]")
    ax.set_ylabel("Magnitude [dB]")
    ax.set_title("Power spectrum")
    ax.grid(which="major")
    ax.grid(which="minor", linestyle=":")
    plt.xlim(11,25000)
    ax.set_xticks([16,31.5,63,125,250, 500,1000,2000,4000,8000,16000])
    ax.set_xticklabels(['16', '31.5', '63', '125', '250', '500', '1k', '2k', '4k', '8k', '16k'])
    plt.legend(loc="upper right")
    plt.tight_layout()
    plt.show()

if __name__ == '__main__':


    file_30min = "A0_lydfil.wav"
    file_calibration_before = "ZOOM0008_Tr1.WAV"
    file_calibration_after = "ZOOM0012_Tr1.WAV"

    A = plotCalibrationBefore(file_calibration_before,file_calibration_after)

    samRate, thirtyminData = wavfile.read(file_30min)
    thirtyminData = thirtyminData / A


    #### Set plot=False if you dont want to plot the entire signal uncompressed
    plotSeperate(thirtyminData,samRate,True, samRate * 6)


